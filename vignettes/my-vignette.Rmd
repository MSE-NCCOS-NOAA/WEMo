---
title: "Getting Started with WEMo"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Getting Started with WEMo}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>",
  fig.dim = c(6, 4),
  fig.align = 'center'
)

library(WEMo)
```

```{r, inlcude = FALSE}
if (!requireNamespace("tidyterra", quietly = TRUE)) {
  knitr::opts_chunk$set(eval = FALSE)
  message("tidyterra not installed — vignette chunks won't run.")
}
```

## About WEMo

**WEMo (Wave Exposure Model)** uses linear wave theory to estimate wave height and wave energy while accounting for local water depth effects like shoaling and wave breaking.

Originally written in [insert original language], WEMo previously depended on ESRI’s ArcGIS. This R implementation removes that dependency, making the model more accessible and license-free.

WEMo requires four key inputs:

* A bathymetry raster

* A shoreline polygon

* A summarized wind history

* A set of site points for which wave exposure will be calculated

The WEMo package also includes functions for preparing inputs, summarizing wind data, calculating fetch, and visualizing results.

Original ArcMap Version of WEMo: <https://coastalscience.noaa.gov/science-areas/climate-change/wemo/>

## Input Data Overview

### Bathymetry

Bathymetry describes underwater terrain, which influences wave growth and breaking. WEMo requires bathymetry as a raster (GeoTIF `.tif`), typically in meters relative to a vertical datum like NAVD88. 

### Shoreline

The shoreline defines the land-water boundary for fetch calculations. It should be an `sf` polygon. You can either supply your own shoreline shapefile or generate one from your bathymetry raster using the `shoreline_from_bathy()` function.

### Wind

WEMo is a wind-wave only model, other sources of waves like tides and storms are not considered. 

WEMo expects a summary of wind history not raw observations. 

This summarized history must include:

-   **`direction`**: The direction *from* which the wind blows (degrees off North, like a compass)

-   **`proportion`**: Fraction of time wind comes from each direction

-   **`speed`**: Wind speed used for wave generation (e.g., mean or percentile)

Use `get_wind_data()` to download wind history and `summarize_wind_data()` to summarize them for WEMo.

### Site Points

Site points define where WEMo will compute wave exposure. Supply as an `sf` point object.

For broader spatial coverage, create a grid using `generate_grid_points()`.

# Running WEMo

## Installation

```{}
# Ensure you have the remotes package installed, if not download and install it
if(!require(remotes)) install.packages("remotes")

# Download the latest version of WEMo from github
remotes::install_github("QAWalker/WEMo")

```

## Load Libraries

```{r load libraries}
# Load WEMo into your environment
library(WEMo)

# We use terra for raster data handling
library(terra)

# We use sf for other spatial data handling
library(sf)

# We use ggplot2 to create visualizations
library(ggplot2)

# We use tidyterra to help ggplot2 with objects created in terra
library(tidyterra)

# we also set the default theme for plotting
theme_set(theme_minimal())
```

## Load our input data

WEMo has a suite of example data which is utilized in this example.

### Bathymetry

This raster should cover the full extent of the area that you might expect to be reached by fetch rays from your site. 

```{r read bathy data}
# load bathymetry
PI_bathy <- terra::rast(system.file("extdata", "PI_bathy.tif", package = "WEMo"))

# plot the bathy raster
ggplot() +
  geom_spatraster(data = PI_bathy)+
  labs(fill = "Bathymetry (m NAVD88)")
```

### Site Points

```{r import and plot points}
# PI_Points is a sf object containing 3 points
ggplot()+
  geom_sf(data = PI_points, color = "red", size = 3)
```

### Shoreline

```{r import and plot shoreline}
# PI_shoreline is a polygon representing the MHHW shoreline (0.552 m NAVD88)
ggplot()+
  geom_sf(data = PI_shoreline, fill = "honeydew3")
```

### Plot All Input Spatial Data

```{r plot shoreline and points}
ggplot()+
  geom_spatraster(data = PI_bathy)+
  geom_sf(data = PI_shoreline, fill = "honeydew3")+
  geom_sf(data = PI_points, color = 'red')+
  labs(fill = "Bathymetry (m NAVD88)")

```

### Wind

```{r inspect example wind data}
# PI_wind_data contains local wind observations from 2023 - 2024
head(PI_wind_data)
```

WEMo wants a summary of the wind history data i.e. one proportion and speed value for each direction.

```{r summarize wind, eval = T}
# create a vector from 0 to 350 by 10 to snap the input wind_directions to
wanted_directions <- seq(from = 0, to = 350, by = 10)

# calculate the 95th percentile wind speed every 10 degrees
wind_data_summary <- summarize_wind_data(
  wind_data = PI_wind_data,
  wind_percentile = 0.95,
  directions = wanted_directions
)

head(wind_data_summary)
```

Plot the summarized wind as a wind rose:

```{r plot summarized wind data in a wind rose, eval=TRUE}
wind_rose_plot <- wind_rose(wind_data = wind_data_summary)

# update the title, subtitle and fill description and change the color scale for the filled bars
wind_rose_plot <- wind_rose_plot +
  labs(
    title = "Pivers Island Wind History", 
    subtitle = "2023-2024",
    fill = "95th %tile Wind\nSpeed (m/s)"
  ) +
  scale_fill_viridis_c(option = "C")

wind_rose_plot
```
*NOTE: `wind_rose()` creates a `ggplot` object that can be saved or further manipulated to match your needs. Read more about controlling and customizing plots in `ggplot2` here: <https://ggplot2.tidyverse.org/>*

## Using Your Own Data

Use `terra` to load rasters

```{r, eval = FALSE}
my_bathy <- terra::rast("/path/to/data/bathy.tif")
```

use `sf` to load other spatial files

```{r, eval = FALSE}
my_points <- sf::st_read("/path/to/data/points.shp")

my_shoreline <- sf::st_read("/path/to/data/shoreline.shp")
```

Read in wind data saved in `.csv` format

```{r, eval = FALSE}
my_wind <- read.csv("/path/to/data/wind_data.csv")
```

or find and download wind data with the `get_wind_data()`

```{r download wind dummy, eval = FALSE}
PI_wind_data <- get_wind_data(PI_points, 2023:2024, which_station = "ask")

```

*NOTE: `get_wind_data()` uses the package `worldmet` <https://openair-project.github.io/worldmet/> to access NOAA Integrated Surface Database (ISD) meteorological observations data.*

With the argument `which_station` set to `"ask"` you'll be prompted to select a weather station (and an interactive map to see where they are in relation to each other):

```         
Choose a met station
Available stations: 

1: 994975-99999 BEAUFORT  NC (0.5 km), 2008-01-01 to 2025-06-25
2: 723037-93765 MICHAEL J SMITH FLD ARPT (2.7 km), 2006-01-01 to 2025-06-26
3: 994160-99999 CAPE LOOKOUT  NC (17.2 km), 1985-01-20 to 2025-06-25
4: 723090-13754 CHERRY POINT MCAS (28 km), 1973-01-01 to 2025-06-26
5: 723097-93743 BOGUE FIELD MARINE CORPS AUXILIARY FIELD (32.8 km), 1987-05-04 to 2025-06-26

Selection:
```

Enter the number of the station what you would like to download and then data will download and be ready to be saved to disk or moved through the workflow.

# Run WEMo with `wemo_full()`

```{r run wemo, eval = TRUE}
wemo_output <- wemo_full(
  site_points = PI_points,
  shoreline = PI_shoreline,
  bathy = PI_bathy,
  wind_data = wind_data_summary,
  directions = wanted_directions,
  max_fetch = 1000,
  sample_dist = 10,
  water_level = 0.552,
  depths_or_elev = "elev"
)

```

`wemo_full()` returns two objects
```{r}
names(wemo_output)
```

`wemo_final` contains the summary stats at each site

```{r}
wemo_output$wemo_final

# wemo_output$wemo_final can be plotted with input data 
ggplot()+
  geom_sf(data = PI_shoreline)+
  geom_sf(data = wemo_output$wemo_final, aes(color = avg_wave_height), size = 5)+
  scale_color_viridis_c(option = "D")
```

`wemo_details` contains stats about the waves from each fetch ray

```{r}
head(wemo_output$wemo_details)

# wemo_output$wemo_details can be plotted with input data 
ggplot()+
  geom_sf(data = PI_shoreline)+
  geom_sf(data = wemo_output$wemo_details, aes(color = wave_height_final), linewidth = 1)+
  scale_color_viridis_c(option = "H")
```

*NOTE: Notice how the fetch rays do not reach all the way to the shoreline in some directions? These are effective or cosine weighted fetch rays. They are constrained by the fetch rays that surround them. Additionally, the parameter `max_fetch` constrains the maximum distance that fetch rays are drawn. If you'd like to plot or save the full fetch rays the function `find_fetch()` creates the fetch rays and returns a object that can be saved or plotted.* 
**[Do i need this effective fetch explanation or can I refer to more source?].**

Most users will probably only want the data from `wemo_final`, but `wemo_details` can be useful to understand why the results in `wemo_final` are what they are.

## Saving Results

```{r, eval=FALSE}
sf::st_write(wemo_output$wemo_details, "/path/to/save/wemo_details.shp")
sf::st_write(wemo_output$wemo_final, "/path/to/save/wemo_final.shp")

# Export as CSV
results_df <- st_drop_geometry(wemo_output$wemo_final)
write.csv(results_df, "/path/to/save/results.csv")
```

# Re-Running With Modified Inputs

`wemo_full()` is great because it doesn't require working with any intermediate products of WEMo. But what if you'd like to see how the model output changes with a different wind regime or with sea level rise? Running `wemo_full()` again works, but re-computes fetch and bathymetry each time.

For faster iteration, prepare inputs once: 

```{r create inputs}
inputs <- prepare_WEMo_inputs(
  site_points = PI_points,
  shoreline = PI_shoreline,
  bathy = PI_bathy,
  wind_data = wind_data_summary,
  directions = wanted_directions,
  max_fetch = 1000,
  sample_dist = 10,
  water_level = 0.552,
  depths_or_elev = "elev"
)

```

Then run the model:

```{r}
results <- WEMo(fetch = inputs)
```

## Example: Adding Sea Level Rise

```{r add SLR to input data}
# add 0.3 m to each depth value
inputs_SLR <- update_depths(inputs, depth_diff = 0.3)
results_SLR <- WEMo(inputs_SLR)

# compare to previous results
data.frame(
  site = results$wemo_final$site,
  max_wave_height = round(results_SLR$wemo_final$max_wave_height - results$wemo_final$max_wave_height, 3),
  avg_wave_height = round(results_SLR$wemo_final$avg_wave_height - results$wemo_final$avg_wave_height, 3),
  RWE = round(results_SLR$wemo_final$RWE - results$wemo_final$RWE, 3)
)
```

We see a slight increase in wave heights and RWE from raising sea level. Note we didn't change our shorelines and were already running the model at MHHW meaning waves from out original run likely didn't experience breaking or shoaling -- both possible reasons why we don't see a dramatic effect on the results.

## Example: Stronger Winds

```{r run wemo on more windy data}
# Create a copy of the inputs
inputs_windy <- inputs
# Increase wind speed by 25%
inputs_windy$speed <- inputs_windy$speed * 1.25

results_windy <- WEMo(inputs_windy)

# compare to previous results
data.frame(
  site = results$wemo_final$site,
  max_wave_height = round(results_windy$wemo_final$max_wave_height - results$wemo_final$max_wave_height, digits = 3),
  avg_wave_height = round(results_windy$wemo_final$avg_wave_height - results$wemo_final$avg_wave_height, digits = 3),
  RWE = round(results_windy$wemo_final$RWE - results$wemo_final$RWE, digits = 3)
)
```

We see increases in wave heights up to 5 cm for max wave heights and 3.5 cm for average wave heights. Also see a corresponding increase in RWE.

## Comparing Results Senarios

*this is a bit advanced, but a cool visual*

```{r Comparing Results Senarios, fig.dim=c(9, 6)}
# make a data set to combine all results
results_all <- dplyr::bind_rows(
  dplyr::mutate(results$wemo_details, senario = "1. Normal"), 
  dplyr::mutate(results_SLR$wemo_details, senario = "2. SLR"),
  dplyr::mutate(results_windy$wemo_details, senario = "3. 25% Stronger Wind")
)

ggplot()+
  geom_sf(data = results_all, aes(color = wave_height_final), linewidth = 1)+
  scale_color_viridis_c(option = "H")+
  facet_grid(site~senario, labeller = "label_both")+
  theme_bw()
```

