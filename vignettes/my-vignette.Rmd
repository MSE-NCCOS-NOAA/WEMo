---
title: "Getting Started with WEMo"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Getting Started with WEMo}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>",
  fig.dim = c(6, 4),
  fig.align = 'center'
)
```

## About WEMo

**WEMo** (Wave Exposure Model) is an easy-to-use numerical model that uses linear wave theory to calculate actual wave height and derived wave energy while taking into consideration wind generation and local water depth characteristics such as shoaling and dissipation from breaking waves.

The model was originally written in [insert the language it was written in] and depended on calls to a local installation of ESRIâ€™s ArcGIS. The version here was rewritten in R in an effort to break the model out of dependence on an expensive ArcGIS license and to bring the model to broader audience.


The model takes as inputs

-   A Bathymetry Raster
-   A Shoreline Polygon
-   A Wind History Data file
-   A Point File for where you want to run the model

In addition to the model, this package also contains functions prepare input data for the model and visualization. There are functions to download, summarize, and plot wind history data, create shoreline polygons from bathymetry rasters, generate grids of points for the model, and calculate fetch.

<https://coastalscience.noaa.gov/science-areas/climate-change/wemo/>

## Input Data

WEMo requires 4 main inputs:

-   A Bathymetry Raster
-   A Shoreline Polygon
-   A Wind History Data file
-   A Point File for where you want to run the model

I'll discuss a little bit about each input before we move on to running the model.

### Bathymetry

The bathymetry or elevation of underwater terrain is crucial to modeling wave growth. A wave moving through a shallow body of water is constrained and experiences breaking at smaller wave heights than a wave moving through deep water would be.

In WEMo, bathymetry data is supplied as a raster layer, a GeoTIFF (.tif) file, typically in units of meters above a fixed datum like NAVD88 (e.g., more negative values representing lower elevations). We also provide methods of dealing with rasters that supply values in water depth (e.g. more postive values represent deeper water or lower elevations)

### Shoreline

The shoreline input defines the land-water boundary and acts as a barrier for fetch calculations. WEMo expects the shoreline as a polygon layer in an sf format. You can either supply your own shoreline shapefile or generate one from your bathymetry raster using the `shoreline_from_bathy()` function.

### Wind

WEMo is a wind-wave only model, other sources of waves like tides and storms are not considered. For WEMo, wind drives wave generation.

WEMo expects a summary of wind history. Note that is not the full wind history, but a summarized one. This summarized history should have the following columns:

-   **`direction`**: The direction *from* which the wind blows (degrees off North, like a compass)

-   **`proportion`**: The proportion of total observations from which the wind blew from this direction. This tells WEMo how frequently waves from this direction arrive at the site.

-   **`speed`**: The wind speed at which you want WEMo to build the waves. This might be the average, the 95th percentile or the max depending on what you're investigating.

Each row in wind data should represents a unique direction that you want build waves for. The included function `summarize_wind_data()` will take you from a full wind history (with each row representing an observation) to a summarized version that WEMo can use. The included function `get_wind_data()` will find and download a wind history for you. More on that in the "*Gathering Data for WEMo*" vignette.

### Points

WEMo needs to know where to draw fetch lines and build wave to. WEMo expects an `sf` object. This can be a shapefile read into R or created in R.

One of the strongest ways to understand the wind wave environment a site is to not run WEMo for a single point, but to run it for a many points. The included function `generate_grid_points()` will make a grid of points that can be run in WEMo. Again, see the "*Gathering Data for WEMo*" vignette for more.

# Running WEMo

## Installation

To begin make sure you have the latest version of WEMo installed from GitHub:

```{}
# Ensure you have the remotes package installed, if not download and install it
if(!require(remotes)) install.packages("remotes")

# Download WEMo from github
if(!require(WEMo)) remotes::install_github("QAWalker/WEMo")
# Load WEMo into your environment
library(WEMo)
```

## Load Libraries

Lets load the libraries that we'll need to read, manipulate and plot spatial data

```{r load libraries}
# We use terra for raster data handling
library(terra)

# We use sf for other spatial data handleing
library(sf)

# We use ggplot2 to create vizualizations
library(ggplot2)

# We use tidyterra to help ggplot2 with objects created in terra
library(tidyterra)

# we also set the default theme for plotting
theme_set(theme_minimal())
```

## Load our input data

Lets load in the inputs to our model

### Bathymetry

Let's start with the Bathmetry data.

This raster should cover the full extent of the area that you might expect to be reached by fetch rays from your site. Processing time can be sped up by reducing the size of this raster to only the nessesary extent. `terra::crop()` will help crop it to the size that is nessesary. I discuss this more in the "*Gathering Data for WEMo*" vignette.

```{r read and plot bathy data}
bathy <- terra::rast( "~/R/My Packages/WEMo/inst/extdata/PI_bathy.tif")

# lets take a look at our bathymetry data
ggplot()+
  geom_spatraster(data = bathy)

```

### Shoreline and points

Lets add the example shoreline polygon and a some points where we're interested in exposure to wind-waves.

```{r load wind, points and shoreline, include = FALSE}
library(WEMo)
library(scales)

load("~/R/My Packages/outdated functions/data temp storage/data/points.rda")
load("~/R/My Packages/outdated functions/data temp storage/data/shoreline.rda")

wind_data <- read.csv("~/R/My Packages/WEMo/inst/extdata/PI_winddata.csv")

```

```{r dummy import points and shoreline, eval = FALSE}
points <- sf::st_read("~/R/My Packages/WEMo/inst/extdata/PI_points.shp")

shoreline <- sf::st_read("~/R/My Packages/WEMo/inst/extdata/PI_shoreline_MHHW.shp")
```

Now lets plot our bathy, shoreline and points all together. We'll make the land greenish and the points red so they standout.

```{r plot shoreline and points}
ggplot()+
  geom_spatraster(data = bathy)+
  geom_sf(data = shoreline, fill = "honeydew3")+
  geom_sf(data = points, color = 'red')

```

Everything looks good so lets move on the wind data

### Wind

Wind data can be found for your point using the included function `get_wind_data()` this is a wrapper around two functions from the package `worldmet` which identifies NOAA meterogological observation stations and downloads the data. The function also cleans the data and gets it ready to be fed into `summarize_wind_data()`.

I won't run this code here, but this is what it would look like to use this function to download wind data

```{r download wind dummy, eval = FALSE}
wind_data <- get_wind_data(points, 2023:2024, which_station = "ask")

```

With the argument `which_station` set to `"ask"` the function will provide you a list of stations (and an interactive map to see where they are in relation to each other) and prompt you to pick which you'd like to choose like this:

```         
Choose a met station
Available stations: 

1: 994975-99999 BEAUFORT  NC (0.5 km), 2008-01-01 to 2025-06-25
2: 723037-93765 MICHAEL J SMITH FLD ARPT (2.7 km), 2006-01-01 to 2025-06-26
3: 994160-99999 CAPE LOOKOUT  NC (17.2 km), 1985-01-20 to 2025-06-25
4: 723090-13754 CHERRY POINT MCAS (28 km), 1973-01-01 to 2025-06-26
5: 723097-93743 BOGUE FIELD MARINE CORPS AUXILIARY FIELD (32.8 km), 1987-05-04 to 2025-06-26

Selection:
```

Enter the number of the station what you would like to download and then data will download and be ready to be saved to disk or moved through the workflow.

Lets take a look at the structure of the `wind_data` object

```{r look at wind data}
wind_data
```

There's a time and date associated with each observed `wind_direction` and `wind_speed`.

Next you'll need to summarize the wind data. WEMo wants to know one speed value for each direction. The aptly named function `summarize_wind_data()` does this for you. Because we're interested in what the upper range of wave energy conditions are like at these sites, I'll ask the function to return the 95th percentile wind speed. That is the speed which is greater than 95% of all other observations at the site. You can pass any value from 0 - 1 to get the percentile wind speed as well as the special case `"mean"` to return the average.

I'll also go ahead and provide a list of directions that I want the observed wind to be snapped to since I saw previously that the observed `wind_directions` hadn't always been rounded to the same level. I'll use every 10 degrees as the target directions to get a total of 36 directions for the wind

```{r summarize wind, eval = T}
wanted_directions <- seq(from = 0, to = 350, by = 10)

wind_data_summary <- summarize_wind_data(
  wind_data = wind_data,
  wind_percentile = 0.95,
  directions = wanted_directions
)

wind_data_summary
```

Lets take a look at the summarized wind data using the included function `wind_rose()`. The `wind_rose()` creates a `ggplot` object that can be saved or further manipulated to match your needs.

Here, I update the labels to better describe our input data (using `labs()`) and change the color scheme of the bars (using `scale_fill_virdis_c()`). Read more about controlling and customizing plots in `ggplot2` here: <https://ggplot2.tidyverse.org/>

```{r plot summarized wind data in a wind rose, eval=TRUE}
wind_rose_plot <- wind_rose(wind_data = wind_data_summary)

wind_rose_plot <- wind_rose_plot +
  labs(
    title = "Pivers Island Wind History", 
    subtitle = "2023-2024",
    fill = "95th %tile Wind\nSpeed (m/s)"
  ) +
  scale_fill_viridis_c(option = "C")

wind_rose_plot
```

You can save this plot using `ggplot2::ggsave()`

```{r save wind rose, eval = FALSE}
ggsave(wind_rose_plot, height = 4, width = 5, units = 'in', dpi = 150, filename = "~/path/to/save/plot.png")
```

The data matches my expectations for the area and we're now ready to send it to WEMo.

## Run the Model

WEMo works behind the scenes by drawing fetch lines from the supplied points to the shoreline in the directions of the input wind data [do I need an explaination of fetch here?], calculating the cosine weighted fetch or effective fetch, interrogating the bathymetry along each fetch ray, and then building the waves along each fetch ray.

You can do this whole process with a call to `wemo_full` (more on other ways to run the model later).

The `wemo_full` function requires several inputs. 

* `site_points` - the points where you want to run the model
* `shoreline` - the shoreline polygon
* `bathy` - the bathymetry raster
* `wind_data` - the *summarized* wind data
* `directions` - Numeric vector of directions (in degrees) to cast fetch lines. Here I just reuse the `wanted_directions` from summarizing the wind data
* `max_fetch` - the maximum distance you want to draw fetch lines from your point. If not supplied, the default is 10,000. We'll just use 1000 in this example.
* `sample_dist` - the iteration distance for interrogating the bathymetry and building the wave. Smaller sample distances will generate more accurate waves, but will increase processing time. Consider the resolution of the bathymetry raster when choosing this value -- a `sample_dist` much smaller than the raster resolution adds processing time without improving model results. We'll use 10 in this example.
* `water_level` the water level that you want to run WEMo for. This value is the values of `bathy` that defines underwater/above water. I'm using a water level of 0.552 m NAVD88 which represent Mean Higher High Water at the tide gauge near our site. This is also the contour for which we drew the shoreline polygon when it was created. See the *"Gathering Data for WEMo"* vignette for more on that.
* `depths_or_elev` -  Use `"depths"` to tell WEMo that the values in `bathy` are water depths and use `"elev"` to tell WEMo that the values in `bathy` are seafloor elevations. Defaults to `"elev"`.
* `extra_at_start` - logical. Indicates if you want the remainder of the fetch ray after dividing it into pieces of length `sample_dist` at the start (close to your site) of the ray or not. Defaults to `TRUE`


```{r run wemo, eval = TRUE}
wemo_output <- wemo_full(
  site_points = points,
  shoreline = shoreline,
  bathy = bathy,
  wind_data = wind_data_summary,
  directions = wanted_directions,
  max_fetch = 1000,
  sample_dist = 10,
  water_level = 0.552,
  depths_or_elev = "elev",
  extra_at_start = TRUE
)

head(wemo_output)
```

Success! WEMo computed wind-wave exposure at your sites. 

## Plot and Save The Results

Looking at the print out of the results, we see that `wemo_output` contains two entries:

* **`wemo_details`** contains information about the wave that arrives at the site from each fetch ray. Spatial geometries are line segments representing fetch rays.
* **`wemo_final`** contains a summary of wave energy environment at each site. Spatial geometry are points representing the sites.

Both `wemo_details` and `wemo_final` are spatial objects that can be plotted and saved. 

### Plotting Results

Lets do that now starting with `wemo_final`. We'll use the argument `aes(color = RWE)` to tell ggplot to color the points by the RWE:

```{r plot final results}
ggplot()+
  geom_spatraster(data = bathy) +
  geom_sf(data = shoreline, fill = "honeydew3") +
  geom_sf(data = wemo_output$wemo_final, aes(color = RWE), size = 3)+
  scale_color_viridis_c(option = "D")+
  labs(color = "RWE (j/m)", 
       fill = "Bathymetry (m NAVD88)")

```

Most user will probably only want the data from `wemo_final`, but `wemo_details` is may be useful to visualize the fetch rays and to inspect if you're curious. Let's take a look:

```{r plot fetch ray results}
ggplot()+
  geom_spatraster(data = bathy) +
  geom_sf(data = shoreline, fill = "honeydew3") +
  geom_sf(data = wemo_output$wemo_details, aes(color = wave_height_final))+
  scale_color_viridis_c(option = "C")+
  labs(color = "Wave Height (m)", 
       fill = "Bathymetry (m NAVD88)")

```

Notice how the fetch rays do not reach all the way to the shoreline in some directions? These are effective or cosine weighted fetch rays. They are constrained by the fetch rays that surround them. [Do i need effective fetch explanation or can I refer to more source?]. Additionally, the parameter `max_fetch` constrains the maximum distance that fetch rays are drawn. If you'd like to plot or save the full fetch rays the function `find_fetch()` creates the fetch rays and returns a object that can be saved or plotted.

### Save Results

You can save these spatial objects as shapefiles to send to other GIS applications or to be used later.

```{r, eval=FALSE}
sf::st_write(wemo_output$wemo_details, "/path/to/save/wemo_details.shp")

sf::st_write(wemo_output$wemo_final, "/path/to/save/wemo_final.shp"
```

You can also turn the final results to a data.frame to be saved as a .csv file

```{r, eval=FALSE}
results_df <- st_drop_geometry(wemo_output$wemo_final)


write.csv(results_df, file = "/path/to/save/results.csv")
```


# Re-running With More Data

`wemo_full()` is great because it doesn't require working with any intermediate products of WEMo. But what if you'd like to see how the model output changes with a different wind regime or if there's 30cm of sea level rise? Re-running `wemo_full()` with new input is a fine way to do this, but it does ask your computer to duplicate compute intensive tasks that you've already done. These tasks like drawing fetch lines and interrogating the bathymetry layer can be done once and the results saved to make the process of running WEMo again much faster. 

## Prepare Input Data

The function `prepare_WEMo_inputs()` chains together the core components needed to prepare a dataset for WEMo modelling. It calculates fetch lines, effective fetch, interrogates bathymetry, and merges wind data. The return is a spatial object ready for wave modeling.

You'll notice the arguments here are identical to what we fed into `wemo_full()` earlier.

```{r create inputs}
inputs <- prepare_WEMo_inputs(
  site_points = points,
  shoreline = shoreline,
  bathy = bathy,
  wind_data = wind_data_summary,
  directions = wanted_directions,
  max_fetch = 1000,
  sample_dist = 10,
  water_level = 0.552,
  depths_or_elev = "elev",
  extra_at_start = TRUE
)

inputs
```

## Run the model

At this point you have a prepared dataset called `input` that's ready to be modeled. You can send this dataset to the function `wemo()` to the run the model on this input data.

```{r run wemo on inputs}
results <- WEMo(fetch = inputs)

head(results)
```

You'll notice this results in the same output as `wemo_full()`.

## Update input data

*[maybe I should make these functions so that they're easy to use and users don't have to do coding etc?]*

But what if we wanted to see how the model changes if sea level rises 30 cm? To do this we included a convenience `update_depths()` that will increase the depths stored in our `inputs` object by `depth_diff`. If you use a negative value for `depth_diff` the depths will decrease. Lets increase the water level by 30 cm (0.3 m) and send those values to `wemo()`.

```{r add SLR to input data}
# add 0.3 m to each depth value
inputs_SLR <- update_depths(inputs, depth_diff = 0.3)

# and then re-run WEMo with 0.30 m of sea level rise.
results_SLR <- WEMo(inputs_SLR)

results_SLR
```

Lets compare to our previous results

```{r}
data.frame(
  site = results$wemo_final$site,
  max_wave_height = round(results_SLR$wemo_final$max_wave_height - results$wemo_final$max_wave_height, digits = 3),
  avg_wave_height = round(results$wemo_final$avg_wave_height - results_SLR$wemo_final$avg_wave_height, digits = 3),
  RWE = round(results$wemo_final$RWE - results_SLR$wemo_final$RWE, digits = 3)
)
```

I think there's no shoaling/breaking happening at the water level that we ran it at, so nothing happens with the updated SLR. We also didn't update the shoreline, so fetch isn't longer.

Lets update the wind. Lets see how WEMo changes if the 95th percentile wind we calculated earlier increased by 10%.

```{r run wemo on more windy data}
# Create a copy of the inputs
inputs_windy <- inputs
# Increase wind speed by 10%
inputs_windy$speed <- inputs_windy$speed * 1.1
# rerun wemo with new data
results_windy <- WEMo(inputs_windy)

results_windy
```



```{r}

data.frame(
  site = results$wemo_final$site,
  max_wave_height = round(results_windy$wemo_final$max_wave_height - results$wemo_final$max_wave_height, digits = 3),
  avg_wave_height = round(results$wemo_final$avg_wave_height - results_windy$wemo_final$avg_wave_height, digits = 3),
  RWE = round(results$wemo_final$RWE - results_windy$wemo_final$RWE, digits = 3)
)
```

What if we also increased wind speed by 25% in every direction

```{r}
inputs$speed <- inputs$speed *1.25

results_increasewind <- WEMo(fetch = inputs)
```


