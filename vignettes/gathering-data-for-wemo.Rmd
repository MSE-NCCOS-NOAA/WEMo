---
title: "Gathering WEMo Data"
output: html_document
vignette: >
  %\VignetteIndexEntry{Gathering WEMo Data}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>",
  fig.dim = c(6, 4),
  fig.align = 'center'
)

```

# Overview

Before running WEMo simulations, you must gather the necessary spatial and environmental input data. This vignette introduces the WEMo functions used to:

* Download historical wind data
* Download bathymetry data
* Generate a shoreline from the bathymetry
* Generate points in a regularly spaced grid

Many of the functions here allow users to easily download and quickly use publicly available data, but these should not be viewed as the only source that users can or should use to run the model. There are so many other sources of public data that may be better suited for your question or perhaps collecting your own data may be the best. WEMo is flexible to use whatever data you'd like.

I'll focus here on data created within this WEMo environment but, spatial data like shapefiles and geotifs created in other GIS programs can be easily read with R using packages [`sf`](https://r-spatial.github.io/sf/) (for simple features i.e. shapefiles) and [`terra`](https://rspatial.github.io/terra/) (for rasters and shapefiles). Both packages are well developed and plenty of help is available online. [how useful is this section? is it too informal?]

# Gather input data

First, initialize libraries

```{r load libraries}
library(WEMo)

library(sf)

library(terra)

library(ggplot2)

library(tidyterra)
```

## Define Site Point

To demonstrate the process of gathering and prepareing data for WEMo, we'll collect data for an example analysis in Sinepuxent Bay near Assateague Island National Seashore, Maryland. 

```{r create a site_point}
# create a point at an area of interest in Sinepuxent Bay Maryland
site_point <- st_point(c(-75.168008, 38.223823))  %>% 
  st_sfc(crs = 4326) %>% # set CRS to WGS84
  st_sf()

```

## Wind Data

Use `get_wind_data()` to retrieve and download wind observations from the NOAA Integrated Surface Database (ISD). The returned data frame includes timestamps, wind speed (m/s), and direction (degrees). 

```{r download wind data, eval = T}
# download wind data from 2020 - 2023 from the closest station to our point
wind_data <- get_wind_data(site_point, 2020:2023, which_station = 1)

# examine the downloaded wind_data
head(wind_data)
```

The `which_station` variable indicates to download the data from the nth closest station to your point. Usually you'll want the closest station (`which_station = 1`), but that might not always be true. For example, if the years of interest are missing or the closest station is not representative of your site.

Setting `which_station` to `"ask"` provides a list and an interactive map of the 5 closest stations and allows you to choose which you'd like.

```{r demo the ask function, eval = F}
wind_data <- get_wind_data(site_point, 2020:2024, which_station = "ask")
```

```         
Choose a met station
Available stations: 

1: 745946-93786 OCEAN CITY MUNICIPAL ARTP (10.3 km), 2006-01-01 to 2025-07-16
2: 998211-99999 OCEAN CITY INLET (12.7 km), 2008-09-15 to 2025-07-14
3: 723980-93720 SALBRY-OCN CTY WICO RGNL AP (32.8 km), 2005-01-01 to 2025-07-16
4: 724020-93739 WALLOPS FLIGHT FACILITY AIRPORT (41.2 km), 1973-01-01 to 2025-07-16
5: 724093-13764 SUSSEX COUNTY AIRPORT (54.5 km), 2006-01-01 to 2025-07-16

```

Type your selection and hit ENTER.

*NOTE:`get_wind_data()` uses the package `worldmet` <https://openair-project.github.io/worldmet/> to access NOAA Integrated Surface Database (ISD) meteorological observations data.*

*For general information of the ISD see https://www.ncei.noaa.gov/products/land-based-station/integrated-surface-database*

### Summarizing Wind Data

WEMo expects a summary of wind history not raw observations. 

This summarized history must include:

-   **`direction`**: The direction *from* which the wind blows (degrees off North, like a compass)

-   **`proportion`**: Fraction of time wind comes from each direction

-   **`speed`**: Wind speed used for wave generation (e.g., mean or percentile)

The function `summarize_wind_data()` prepares data gathered from the `get_wind_data()` function to be used in WEMo. 

```{r summarize wind, eval = T}
# create a vector from 0 to 350 by 10 to snap the input wind_directions to
wanted_directions <- seq(from = 0, to = 350, by = 10)

# calculate the 95th percentile wind speed every 10 degrees
wind_data_summary <- summarize_wind_data(
  wind_data = PI_wind_data,
  wind_percentile = 0.95,
  directions = wanted_directions
)

head(wind_data_summary)

# make a wind rose
wind_rose(wind_data_summary)
```

Input `wind_direction` values are coerced into values 0-359.9. The function can further snap input `wind_directions` to a user supplied vector of suitable directions (`directions`). Input `wind_directions` are rounded to the nearest value in `directions`. This is often necessary with input data from public data sets that have occasional anomalous readings. If `directions` is not supplied the output is based on all unique values in `wind_data$wind_direction`.

The function will accept `wind_percentile` values from 0 to 1 or `"mean"`. The returned `speed` value indicates the corresponding stat of all observations from that direction.


`NA` values in the **`wind_direction`** column indicate calm data if the `wind_speed` column is 0. However, `NA` values in the **`wind_speed`** column are considered bad data and are removed when `wind_speed_na.rm = TRUE` (the default). Here I'll generate random example data with `NA`s and summarize speed to the mean:

```{r demo calm wind}
# create some dummy data with NAs in the speed and direction columns
wind_data_random <- data.frame(
  wind_direction = c(runif(n = 5, min = 0, max = 315),rep(NA, 10)),
  wind_speed = c(runif(5, 0, 25), rep(NA, 5), rep(0, 5))
)

# remove the NAs in the speed column. perhaps these are data collection errors
summarize_wind_data(wind_data_random, wind_percentile = 'mean',
  directions = c(90, 180, 270, 360), wind_speed_na.rm = TRUE)

```

But you can set `wind_speed_na.rm = FALSE` to keep them in as calm readings. Usually only `wind_speeds` of 0 are considered calm data:

```{r more calm demo}
# keep the NAs in the speed column. perhaps these represent calm data
# (though normally 0 would indicate calm)
summarize_wind_data(wind_data_random, wind_percentile = 'mean',
  directions = c(90, 180, 270, 360), wind_speed_na.rm = FALSE)

```

### Saving Wind Data

```{r save wind, eval=FALSE}
# save the wind data as a .csv file
write.csv(wind_data, file = "wind_data.csv")

```

## Bathymetry

There are plenty of sources of bathymetric data and it would be impossible to discuss them all here, however NOAA's Bathymetric Data Viewer (https://www.ncei.noaa.gov/maps/bathymetry/) offers an easy to access and interactive viewer to find some of the best publicly available datasets.

We have provided a convenience function `get_noaa_cudem()` to fetch bathymetric data from NOAAâ€™s Continuously Updated Digital Elevation Model (CUDEM). This function accesses data from NOAA's Continuously Updated Digital Elevation Model (CUDEM), specifically the 1/9 Arc-Second Resolution (approx. 3 meter) Topobathymetric dataset https://chs.coast.noaa.gov/htdata/raster2/elevation/NCEI_ninth_Topobathy_2014_8483/. This function takes a input point and radius and downloads topo-bathy .tif raster tiles that intersect that radius.

```{r download bathy data}
# extract lon and lat from our site_point
lon = sf::st_coordinates(site_point)[1]
lat = sf::st_coordinates(site_point)[2]

# download, mosaic and crop CUDEM rasters for our area of interest
bathy <- get_noaa_cudem(
  lon = lon, 
  lat = lat, 
  radius_m = 15000,
  dest_dir = "NOAA_CUDEM",
  mosaic_and_crop = TRUE,
  output_file = "Sinepuxent_Bathy_Cropped.tif", 
  overwrite = F
)

# plot the cropped raster in relation to our site point
ggplot() +
  geom_spatraster(data = bathy) +
  geom_sf(data = site_point, color = 'red', size = 5)

```

The CUDEM dataset accessed by this function covers select areas of the United States, including:

* The East Coast
* The Gulf Coast
* The San Francisco Bay
* Part of the Oregon Coast and the Washington Coast
* The Puget Sound, Washington
* Portions of Cook Inlet, Alaska

Additional CUDEM products, with varying spatial resolutions and geographic extents, are available at: https://www.ncei.noaa.gov/products/coastal-elevation-models

With `mosaic_and_crop = TRUE` the function will stitch together the downloaded rasters and crop them to an area defined by the `radius_m`. This is useful for speeding up processing time by keeping the inputs to WEMo as small as possible. 

With `radius_m = 15000` all topo-bathy data that is within 15,000 meters of our point is fetched. This value was chosen so that the default max fetch distance that WEMo uses (10,000) will be covered by the raster after additional points in a grid of points 500 by 500 meters around this point is created further down the workflow. [need editing for clarification here?]

With `overwrite = TRUE` all intersecting rasters will be re-downloaded even if they are present in the folder. Set `overwrite = FALSE` to skip re-downloading and increase speed. 

*NOTE: that `dest_dir` will create a folder in your working directory if one with that name doesn't exist. You can use `getwd()` to determine where your working directory is. You can also include the full path to your desired folder if that isn't in your working directory. The cropped mosaic raster is also saved to the same directory.*

## Shoreline 

Once you have bathymetry data, use `generate_shoreline_from_bathy()` to generate a shoreline based on a user defined elevation. We'll use Mean Sea Level at a nearby NOAA Water Level Station: [Ocean City Inlet, MD (Station ID: 8570283)](https://tidesandcurrents.noaa.gov/datums.html?id=8570283) to draw the shoreline for the analysis.

```{r generate shorelines}
# MSL at Ocean City Inlet - for the shoreline definition and for use later in the workflow
water_level <- -0.141 # meters NAVD88 (match the bathy data)

# Generate Shoreline and save output to file
shoreline <- generate_shoreline_from_bathy(
  bathy = bathy,
  contour = water_level,
  save_output = TRUE,
  filename = "Shoreline_MSL.shp"
)

# plot the shoreline
ggplot() +
  geom_sf(data = shoreline) +
  geom_sf(data = site_point, color = 'red', size = 5)
```

This shoreline will define the maximum extent of the fetch rays that WEMo calculates. Selecting the proper contour to draw the polygon is critical to your analysis workflow and depends on your question. You can find a listing of stations and their published datums from NOAA CO-OPS' National Water Level Observation Network online: https://tidesandcurrents.noaa.gov/stations.html?type=Datums. Additionally NOAA's vdatum tool will produce datums for your area as well: https://vdatum.noaa.gov/.

Be sure to match the units and vertical datum to your bathy data. Bathy data from `get_noaa_cudem()` is in meters relative to NAVD88.

## Convert all Inputs to UTM

We want work in meters and also keep all of the inputs in the same coordinate reference system. We'll convert all the inputs to the local UTM grid (18N for our site in Sinepuxent Bay, Maryland)

```{r convert to utm}
# Convert to UTM Zone 18N EPSG:32618
site_point <- sf::st_transform(site_point, crs = 32618) 
shoreline <- sf::st_transform(shoreline, crs = sf::st_crs(site_point))
bathy <- terra::project(bathy, terra::crs(site_point))

```

## Grid of Points

Use `generate_grid_points()` to generate a rectangular grid of points. These are the points where WEMo will simulate wave exposure.

```{r generate grid points}
# convert the site_point to a utm grid to work with meters
site_point <- sf::st_transform(site_point, crs = 32618) # WGS 84 / UTM Zone 18N

# create a grid of points 500 x 500 meters with points every 100 meters
grid_points <- generate_grid_points(
  site_point = site_point,
  expansion_dist = 500,
  resolution = 100
)

# plot the grid with the original site point
ggplot() + 
  geom_sf(data = grid_points)+
  geom_sf(data = site_point, color = 'red', size = 5)
```

If `expansion_dist` or `resolution` is a vector of length 2 the x and y expansion distances or grid resolution are set independently.

## Plot All Inputs Together

```{r plot all inputs}
ggplot() +
  geom_spatraster(data = bathy) +
  geom_sf(data = shoreline, fill = "honeydew3") +
  geom_sf(data = grid_points, color = 'red') 
```

### nice

... but we can't really see our points and the bathy color scale is stretched out by the high elevation cells on land and the low elevation cells offshore. 

Lets constrain our input data to fix these problems and make a nice plot:

```{r fancy plot, fig.dim=c(9, 6)}
# Get extent of the grid points
grid_ext <- terra::ext(grid_points)

# Expand the extent by 1500 meters in all directions
exp_dist = 1500

buffered_ext <- terra::ext(
  grid_ext$xmin - exp_dist,
  grid_ext$xmax + exp_dist,
  grid_ext$ymin - exp_dist,
  grid_ext$ymax + exp_dist
)

# crop the bathy to a smaller area
plot_bathy <- terra::crop(x = bathy, y = buffered_ext)

# set all cells in the bathy above our water level to NA
plot_bathy[plot_bathy > water_level] <- NA

# crop the shoreline to a smaller area
plot_shoreline <- st_crop(shoreline, buffered_ext)

# plot
ggplot() +
  geom_spatraster(data = plot_bathy) +
  geom_sf(data = plot_shoreline, fill = "honeydew3", color = NA) +
  geom_sf(data = grid_points, color = "red") +
  coord_sf(expand = FALSE) +
  theme_bw()+
  scale_fill_viridis_c(option = 'mako', na.value = NA)+
  labs(fill = "Bathymetry (m NAVD88)")

```

*Very* nice.

# Run WEMo model

The input data is now ready for WEMo:

```{r run wemo on the points}
# run WEMo at each of the 36 grid points that we made
results <- wemo_full(
  site_points = grid_points,
  shoreline = shoreline,
  bathy = bathy,
  wind_data = wind_data_summary,
  directions = wanted_directions,
  max_fetch = 10000,
  sample_dist = 10,
  water_level = water_level,
  depths_or_elev = 'elev'
)
```


```{r plot results}
# plot the max wave at each site
ggplot() +
  geom_sf(data = results$wemo_final, aes(color = max_wave_height)) +
  theme_bw()+
  scale_color_viridis_c()

# plot using our special plot_ inputs from earlier 
ggplot() +
  # geom_spatraster(data = plot_bathy) +
  # geom_sf(data = shoreline, fill = "honeydew3", color = NA) +
  geom_sf(data = results$wemo_details, aes(color = wave_height_final)) +
  coord_sf(expand = FALSE) +
  theme_bw()+
  scale_color_viridis_c()+
  scale_fill_viridis_c(option = 'mako', na.value = NA)+
  labs(fill = "Bathymetry (m NAVD88)")
```

